[{"title":"Spin Contrib HTTP","content":"This is a library created by Thorsten Hans which contains helpers to build HTTP-based applications with Fermyon Spin.","langauge":"Rust","tags":["test","rust"],"url":"/hub/preview/spin_contrib_http","id":"spin_contrib_http"},{"title":"Spin Message Trigger","content":"A generiuc messaging trigger for undefined. Note this is an experimental/work-in-progress repo, and is not production ready at this point. Also - if you have suggestions for improvements, feel free to make them in the Issues tab.undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedTo install the plugin, run the following command on the system running your spin deployment (or any development machine):spin plugin install --url https://github.com/lee-orr/spin-message-trigger/releases/download/canary/trigger-message.json --yesOnce you've installed the plugin, you can get started quickly installing the templates and using them:spin templates install --git https://github.com/lee-orr/spin-message-trigger --upgradeYou can then set up a new project using:spin new message-appOnce you have that, you can use spin add to set up components, brokers and gateways. Importantly undefined once they are created.\nThe available templates are:\n| Template Name | Description |\n| --- | --- |\n| message-component | This creates a component that gets triggered by a subscription. |\n| request-response-message-component | This creates a component that gets triggered by a request-response message, with an HTTP method & path. |\n| queue-component | This creates a component that gets subscribes to a queue - meaning only one member of the queue group will get triggered for each message. Most useful if you have multiple instances of the spin application running. |\n|  |  |\n| redis-broker | This connects to a redis pub-sub on the provided server |\n| mqtt-broker |  This connects to an Mqtt server |\n| nats-broker |  This connects to a Nats server or cluster |\n|  |  |\n| broker-gateway | This sets up an Http gateway that publishes to one of the brokers in your project |When setting up a spin application with this trigger, there are 3 parts:undefinedundefinedundefinedThe trigger definition object contains two fields - the type, which must be \"message\", and a dictionary of broker configs. Each broker config contains a broker type - a value which changes based on the message broker type - and a gateway definition.More info on the broker types & gateway definition is below.In the example, this section looks like this:# Here we define the trigger message type\n[trigger]\ntype = \"message\"\n\n# This sets up a broker called \"test\", with the \"InMemoryBroker\" type.\n[trigger.brokers.test]\nbroker_type = \"InMemoryBroker\"\n\n# This sets up an HTTP gateway for the test broker on port 3005, and allowing full request/response serialization using JSON.\n[trigger.brokers.test.gateway.Http]\nport = 3_005\nrequest_response = \"Json\"\n\n# This sets up a broker called \"secondary\", which connects to a NATs server at the address \"nats\" (this is handled by docker compose treating that as a domain name).\n[trigger.brokers.secondary.broker_type.Nats]\naddresses = [\"nats\"]\n\n# This sets up an HTTP gateway for the secondary broker on port 3006, and allowing websockets to subscribe to topics published on that broker.\n[trigger.brokers.secondary.gateway.Http]\nport = 3_006\nwebsockets = \"TextBody\"The in memory broker is a simple broker, primarily meant for use in single instance deployments and for testing purposes, with support for wildcard subscriptions.\nIt's configuration is simple:[trigger.brokers.BROKER_NAME]\nbroker_type = \"InMemoryBroker\"The Redis broker provides support for Redis channels, similar to the spin built-in redis trigger, but with additional support for wildcard subscriptions.\nIt's configuration involves setting the redis address, like so[trigger.brokers.BROKER_NAME]\nbroker_type = { Redis = \"redis://redis:6379\" }The NATs broker provides support for subscribing to topics on a NATs broker.\nIt's configuration is more complex than the previous ones:[trigger.brokers.BROKER_NAME.broker_type.NATs]\n# This is required, and contains a list of addresses for the nats servers\naddresses = [\"nats\"]\n\n# Optional - do the servers require tls. defaults to false\ntls = true\n\n# Optional - the interval for pings, in milliseconds.\npint_interval = 10_000\n\n# Optional - path to root certificates\nroot_certificate = \"/path/to/root/certificate\"\n\n# Optional - paths to client certificate files\nclient_certificate = { certificate = \"/path/to/client/cert\", key = \"/path/to/client/key\" }\n\n# Optional - client name\nclient_name = \"the client name\"In addition - there are multiple optional authentication options for NATs:# Token based auth\n[trigger.brokers.BROKER_NAME.broker_type.NATs.auth]\nToken = \"token string\"\n\n# Username & Password authentication\n[trigger.brokers.BROKER_NAME.broker_type.NATs.auth]\nUser = { user = \"username\", password = \"password\" }\n\n# NKey authentication\n[trigger.brokers.BROKER_NAME.broker_type.NATs.auth]\nNKey = \"NKey String\"\n\n# JWT auth\n[trigger.brokers.BROKER_NAME.broker_type.NATs.auth]\nJwt = { nkey_seed = \"nkey seed\", jwt = \"jwt string\" }\n\n# Credentials File\n[trigger.brokers.BROKER_NAME.broker_type.NATs.auth]\nCredentialsFile = \"/path/to/credentials/file\"\n\n# Credentials String\n[trigger.brokers.BROKER_NAME.broker_type.NATs.auth]\nCredentialsString = \"credentials string\"The MQTT broker provides support for MQTT compatible message brokers. Note that it traslates the topic patterns to be consistent with the other brokers - so segments of the topic will be represented with . rather than / and wildcards with * rather than +.\nFor example, the MQTT topic my/topic would be translated into my.topic, and the subscription my/+ would be my.*.It's configuration involves setting the redis address, like so[trigger.brokers.BROKER_NAME.broker_type.Mqtt]\naddress = \"mqtt://mqtt:1883\"\n# Optionally, you can also provide a client id. Otherwise one will be generated.\nid = \"my_id\"\n# Optionally, you can also provide the keep_alive duration, as a f32 in seconds\nkeep_alive = 5.0\n\n# Optionally, you can also set up a username and password\n[trigger.brokers.BROKER_NAME.broker_type.Mqtt.credentials]\nusername = \"username\"\npassword = \"password\"Each broker can have an HTTP gateway defined for accessing it. The gateways expose 3 routes, based on the config:undefinedundefinedundefinedundefinedIf you wish to enable a gateway, you can define the gateway like so:[trigger.brokers.BROKER_NAME.gateway.Http]\n# The port for the Http gateway\nport = 3005\n\n# An optional configuration for websockets - enabling their use for subscribing to subjects on the broker.\nwebsockets = \"BinaryBody\"\n\n# Possible Values:\n\n# BinaryBody - will forward the message body directly as binary data\n# TextBody - will transform the message body to a utf8 string, and forward the string to the client\n# Messagepack - will serialize the input message object, containing the body (a vec of u8's), subject & broker name, to Messagepack \n# Json - will serialize the input message object, containing the body (a vec of u8's), subject & broker name, to Json \n\n# An optional configuration for enabling request/response patterns (with the /request/ route)\nrequest_response = \"Messagepack\"\n\n# Possible Values: \n\n# Messagepack - this will serialize the request into a Messagepack, publish it to the broker, and rely on messagepack for the response as well\n# Json - this will serialize the request into Json, publish it to the broker, and rely on json for the response as wellFor request/response processes - the trigger currently publish messages to special subject names. This is a process one I'd like to change, but haven't had a chance yet.\nThe subjects follow the following format: request.*request_id*.*method*.*path* and response.*request_id*.*method*.*path*. The request id is a Ulid generated per request.The component definition contains a trigger secion, which contains information used to determine triggering & responses for this component.\nSpecifically - the broker field takes the name of the broker this compoment gets triggered by, and the subscription field, which takes an object configuring the subscription.A component can either subscribe to a Topic, a Request or a Queue.The main portion of the general configuration is setting the broker you wish to subscribe to, along with any other common spin component configuration options.[[component]]\nid = \"hello\"\nsource = \"./target/wasm32-wasi/release/example_app.wasm\"\nallowed_http_hosts = []\n[component.trigger]\n# Here we set up the broker we want to subscribe to\nbroker = \"test\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release -p example-app\"A Topic subscription takes a topic string representing the topic being subscribed to - based on the conventions of the specific broker, and an optional result field that allows setting up a defaults for published result messages, allowing them to target a different default broker and subject.Here is one of the component definitions in the example:[component.trigger.subscription.Topic]\n# Here we set up the topic\ntopic = \"hello.*\"\n# Here we set up alternative default publishing targets for this component - so by default it sends messages to the \"good.bye\" subject on the \"secondary\" broker\nresult = { default_broker = \"secondary\", default_subject = \"good.bye\" }A Request requires a path & an optional method, similar to an HTTP router.[component.trigger.subscription.Request]\npath = \"test/*/hello\"\nmethod = \"POST\"\nNote that the path supports segment wildcards, but not variables at the moment.A Queue requires a topic to subscribe to, and a group which names the queue for which only one subscriber will receive each message.\n[component.trigger.subscription.Queue]\ntopic = \"test\"\ngroup = \"queue\"You can build the gateway independantly using cargo build -b gateway and run it uusing cargo run -b gateway. However, it cannot parse the gateway definitions from the spin toml, since it's built primarily for situations where you might host the gateway separately from the actual spin app.As such - you configure it via the cli arguments. To get the up-to-date arguments, run cargo run --bin gateway -- -h. It's important to note that the broker is parsed as a query string. As such - a redis broker might be: cargo run --bin gateway -- --broker Redis=redis://redis:6379 while a nats broker might be: cargo run --bin gateway -- --broker Nats[addresses][0]=\"nats\". It defaults to port 3015.Bi-directional websockets rely on a simple protocol, encoded in either Json or Msgpack (based on whether websocket subscriptions rely on binary or text).To subscribe to a topic, the client should send a message with the following structure:{\n    \"Subscribe\": \"good.*\" \n}\nThe client will receive messages encoding the following structure:{\n    message: Array<u8>, // an array representing the contents of the message\n    subject: String, // the subject the message was published on\n    broker: String, // the name of the broker in the config file\n    response_subject: Option<String> // if it is a request/response, send the response to this subject\n}\nThe client can also publish messages with the following structure:{\n    \"Publish\": {\n        \"message\": Array<u8>,\n        \"subject\": \"good.test\",\n        \"response_subject\": Option<String>\n    }\n}\nThis repository is set up to function as either a Dev Container (using VsCode). This means you can use Github workspaces to get it set up automatically, or use VSCodes \"Clone Repository into Volume\" option to clone the repo & build the dev environment for you.Once you are running, you can use the \"update-plugin.sh\" script to build the plugin and install it on spin.\nThen - run \"spin build\" & \"spin up\" in the workspace root to launch itIf you are using VS Code, you'll notice there are two extensions installed:undefinedundefinedundefinedundefinedundefinedundefined","langauge":"Rust","tags":["test","rust"],"url":"/hub/preview/spin_message_trigger","id":"spin_message_trigger"},{"title":"Spinlet","content":"Spinlet is a plugin and runtime for building and running wasm32-wasi cli components as  undefined for  undefined. It provides a sandboxed environment with access control to protect the host system from malicious code. Spinlet supports features such as std::env::args and std::fs::read_dir, and allows users to specify which environment variables, directories, and files the plugin has access to.Spinlet requires the following tools to be installed:undefinedundefinedundefinedundefinedundefinedgit clone https://github.com/cardoso/spinlet\ncd spinlet\nspin pluginify -i\nspin letundefinedSpinlets can now hook into spin's native commands by specifying in their manifest:[hook.build.after]\nenabled = true\n[hook.build.before]\nenabled = trueundefinedSpinlet's manifest allows users to specify which environment variables, directories, and files the plugin has access to.[[access.fs.dir]]\npath = \".\"\nread = true\n\n[[access.env.var]]\nkey = \"HOME\"\n\n[access.env.args]\nenabled = true\n[access.io.stdin]\nenabled = true\n[access.io.stdout]\nenabled = true\n[access.io.stderr]\nenabled = true\nundefinedfn main() {\n    for arg in std::env::args() {\n        println!(\"{}\", arg);\n    }\n\n    // Plugin only has access to environment variables specified in the manifest\n    for (key, value) in std::env::vars() {\n        println!(\"{}: {}\", key, value);\n    }\n}➜  spinlet git:(main) ✗ spin let update\nYou're using a pre-release version of Spin (1.3.0-pre0). This plugin might not be compatible (supported: >=0.7). Continuing anyway.\n/Users/cardoso/Library/Application Support/spin/plugins/let/let\nupdate\nSPIN_BIN_PATH: /Users/cardoso/.cargo/bin/spin\nSPIN_BRANCH: main\nSPIN_BUILD_DATE: 2023-05-20\nSPIN_COMMIT_DATE: 2023-05-19\nSPIN_COMMIT_SHA: d476000\nSPIN_DEBUG: false\nSPIN_TARGET_TRIPLE: aarch64-apple-darwin\nSPIN_VERSION: 1.3.0-pre0\nSPIN_VERSION_MAJOR: 1\nSPIN_VERSION_MINOR: 3\nSPIN_VERSION_PATCH: 0\nSPIN_VERSION_PRE: pre0undefinedpub fn main() {\n    /// Plugin only has access to files in the current working directory\n    match std::fs::read_dir(\"/workspace\") {\n        Ok(dir) => {\n            for entry in dir {\n                match entry {\n                    Ok(entry) => println!(\"{}\", entry.path().display()),\n                    Err(error) => println!(\"error reading entry: {}\", error),\n                }\n            }\n        }\n        Err(error) => println!(\"error reading /: {}\", error),\n    }\n}➜  spinlet git:(main) ✗ pwd\n/Users/cardoso/Developer/cardoso/spinlet/spinlet\n➜  spinlet git:(main) ✗ spin let workspace\nYou're using a pre-release version of Spin (1.3.0-pre0). This plugin might not be compatible (supported: >=0.7). Continuing anyway.\n/workspace/Cargo.toml\n/workspace/.spinlets\n/workspace/.DS_Store\n/workspace/target\n/workspace/install.sh\n/workspace/let-0.1.5-macos-aarch64.tar.gz\n/workspace/Cargo.lock\n/workspace/README.md\n/workspace/adapters\n/workspace/build.sh\n/workspace/.gitignore\n/workspace/spinlets\n/workspace/.git\n/workspace/let.json\n/workspace/spin-pluginify.toml\n/workspace/srcspin let [spinlet] -- [spinlet args]Usage: spin let [OPTIONS] <SPINLET> [-- <ARGS>...]\n\nArguments:\n  <SPINLET>  Spinlet to run\n  [ARGS]...  Arguments to pass to the\n             spinlet\n\nOptions:\n  -w, --workspace <WORKSPACE>\n          Workspace to run the spinlet\n          in [default: .]\n  -h, --help\n          Print help","langauge":"Rust","tags":["test","rust"],"url":"/hub/preview/spinlet","id":"spinlet"},{"title":"Empty HTTP trigger template","content":"This template creates an HTTP application with no components. It installs by default with the undefined.Use this template when you expect to undefined multiple components to an application, to help you establish an even directory structure.","tags":["http"],"url":"/hub/preview/template_http_empty","id":"template_http_empty"},{"title":"JavaScript HTTP trigger template","content":"This is the default HTTP trigger template for JavaScript. It installs by default with the undefined.This guide walks you through how to use it: [HTTP Components](https://developer.fermyon.com/spin/javascript-components#http-components","langauge":"JS/TS","tags":["javascript","http"],"url":"/hub/preview/template_http_js","id":"template_http_js"},{"title":"Rust HTTP trigger template","content":"This is the default HTTP trigger template for Rust. It installs by default with the undefined.This guide walks you through how to use it: [HTTP Components](https://developer.fermyon.com/spin/rust-components#http-components","langauge":"Rust","tags":["rust","http"],"url":"/hub/preview/template_http_rust","id":"template_http_rust"},{"title":"TypeScript HTTP trigger template","content":"This is the default HTTP trigger template for TypeScript. It installs by default with the undefined.This guide walks you through how to use it: [HTTP Components](https://developer.fermyon.com/spin/javascript-components#http-components","langauge":"JS/TS","tags":["typescript","http"],"url":"/hub/preview/template_http_ts","id":"template_http_ts"}]